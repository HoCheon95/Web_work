<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Array 객체</title>

    <script>
      /*
        
        - Array 객체 ==> 배열을 객체화 한 것

        - 생성
            const 배열명 = new Array(개수);     // '개수'만큼의 크기를 갖는 배열이 생성된다.
            const 배열명 = new Array();         // 0개 짜리 배열 생성
            
            // 주어진 '값들'의 개수만큼의 크기의 배열이 생성되고 주어진 값들로 초기화 된다.
            const 배열명 = new Array(값1, 값2, ..., 값n);
            const 배열명 = [값1, 값2, ..., 값n];

            - 속성
            length  ==> 배열의 개수를 나타낸다.

         */
      /* 
        const a = new Array(5);
        console.log("생성된 직후의 배열의 개수 : " + a.length);

        a[0] = 100;
        a[1] = 200;
        a[2] = 300;
        a[3] = 400;
        a[4] = 500;

        for(let i=0; i<a.length; i++){
            console.log("a[" + i + "] = " + a[i]);
        }

        //자바스크립트의 배열은 현재 개수에서 사용되는 첨자(index) 값보다 큰 값을 사용하면 자동으로 
        // 그 첨자 값에 맞는 개수로 확장된다.
        a[5] = 600;
        a[6] = 700;
        a[7] = 3.14;
        a[8] = "가나다";
        a[9] = false;

        a[15] = "안녕!!!";
        console.log("확장 후 배열의 개수 : " + a.length);

        for(let i=0; i<a.length; i++){
            console.log("a[" + i + "] = " + a[i]);
        }

        console.log("------------------------------------------");
        
        const b = new Array("홍길동", "이몽룡", "변학도", "이순신", "강감찬");
        
        for(let i=0; i<b.length; i++){
            console.log("b[" + i + "] = " + b[i]);
        }
        
        console.log("------------------------------------------");

        const c = ["서울", "대전", "대구", "부산"];
        for(let i = 0; i<c.length; i++){
            console.log(`c[${i}] = ${c[i]}`);
        } 
        */

      /*
        문제) 사람 이름을 계속 입력 받아서 배열에 저장하고 사용자가 공백(빈문자열)이나 '취소' 버튼을 누르면 그 때까지
        입력한 이름을 출력하는 프로그램을 작성하시오.
        */

      /*         
        const nameList = new Array();   // 0개짜리 배열 생성
        let i=0; //인덱스



        while(true){
            let name = prompt("이름을 입력하세요.");

            if(name == " " || name == null){
                break;
            }
            nameList[i] = name;
            i++;
        }

        for(let i=0; i<nameList.length; i++){
            console.log(`nameList[${i}] = ${nameList[i]}`);
        }
         */

      /* 
        문제) 서로 중복되지 않는 정수 5개를 입력 받아서 출력하는 프로그램을 작성하시오.
        */
      /* 
        const numArray = new Array(5);

        for(let i =0; i<numArray.length; i++){
            let num = Number(prompt(`${i+1} 번째 정수를 입력하세요.`));

            let flag = false;   //데이터 중복되면 true로 변경된 변수
            for(let j=0; j<i; j++){
                if(numArray[j] == num){//중복
                    flag = true;
                    break;
                }
            }

            if(flag == true){
                i--;
                continue;
            }
            
            numArray[i] = num;
            
        }

        for(i = 0; i<numArray.length; i++){
            console.log(`numArray[${i}] = ${numArray[i]}`);
        }
        
        for(let tmp in numArray){
            console.log("numArray[" + tmp + "] = " + numArray[tmp]);
        }
        for(let value of numArray){
            console.log(value);
        }
        
        console.log("------------------------------------------");      
        
        */

      /*
            Array 객체의 메서드들...

        - indexOf(값, 시작위치);
        - lastIndexOf(값, 시작위치);
            ==> 배열에서 '값'의 위치(첨자)를 반환한다.
            ==> 배열에 '값'이 없으면 '-1' 반환한다.
            ==> indexOf()는 앞에서 뒤쪽 방향으로 검색을 진행하고
                lastIndexOf()는 뒤에서 앞쪽 방향으로 검색을 진행한다.
            ==> '시작위치'는 검색을 위치값으로 이것을 생략하면
                indexOf()는 처음부터, lastIndexOf()는 마지막 위치부터 검색을 시작한다.

        - includes(값)  ==> 배열에 '값'이 있으면 true, 없으면 false를 반환한다.
        */

      /*         
        const a = new Array(60, 100, 70, 90, 80, 85, 70, 95, 65);

        let b = a.indexOf(70);
        console.log("b = " + b);            // 2
        console.log(a.lastIndexOf(70));     // 6
        console.log(a.indexOf(70,4));       // 6
        console.log(a.lastIndexOf(70,4));   // 2
        console.log(a.indexOf(50));         // -1
        console.log("---------------------");

        console.log(a.includes(80));
        console.log(a.includes(40));
 */

      /*
        - join(연결문자)
            ==> 배열의 각 요소값들을 ‘연결문자’로 연결하여 하나의 문자열로 반환한다.
            ==> ‘연결문자’를 생략하면 기본값은 ‘쉼표(,)’가 된다.
        
        - push( 데이터들...)
            ==> 배열의 끝에 '데이터들....'을 추가한다.

        - pop()
            ==> 배열의 마지막 위치의 요소값을 읽어와 반환하고 배열에서 마지막 위치의 요소값을 삭제한다.
        */

      /*         
        const a =["홍길동", "일지매", "이몽룡"];
        console.log("변경 전 : " + a.join("$$"));
        //console.log("변경 전 : " + a.join());
        
        a.push("성춘향", "이순신");
        console.log("push 작업 후 : " + a.join("$$"));
        
        let b = a.pop();
        console.log("pop 작업 후 가져온 데이터 b = " + b);
        console.log("pop 작업 후 : " + a.join());
 */

      /*
        - unshift(데이터들...)
            ==> 배열의 처음위치에 '데이터들...'을 추가한다.
        - shift()
            ==> 배열의 첫번째 위치의 요소값을 읽어와 반환하고, 배열에서 첫번째 위치의 요소값을 삭제한다.


        */
      /* 

        const a =["홍길동", "일지매", "이몽룡"];
        console.log("변경전 : " + a.join());

        a.unshift("성춘향", "이순신");
        console.log("unshift 작업 후 : " + a.join());

        let c = a.shift();
        console.log("shift 작업 후 가져온 데이터 c = " + c);
        console.log("shift 작업 후 : " + a.join());

         */

      /*
        - reverse()
            ==> 배열의 요소값들을 현재 순서의 역순으로 재배열한다.
        */
      /* 
        const a =["홍길동", "일지매", "이몽룡"];
        console.log("변경전 : " + a);       // 배열을 출력할 때 '배열명'만 지정하면
                                            // '배열명.join()'과 같이 처리한다.
        a.reverse();
        console.log("reverse 변경 후 : " + a);
         */

      /*
        - 배열1.concat(배열2)
            ==> '배열1'의 끝에 '배열2'의 요소값들을 추가한 새로운 배열을 생성해서 반환한다.
        */

      /*         
        const a = ["대전", "대구", "목포", "인천"];
        const b = [10, 20, 30, 40, 50];

        const c = a.concat(b);
        console.log("배열 a => " + a);
        console.log("배열 b => " + b);
        console.log("배열 c => " + c);
 */

      /*
        - slice(시작위치, 종료위치)
            ==> 배열의 '시작위치'부터 '종료위치' 이전까지의 요소값들을 추출하여 배열로 반환한다.
        */

      /*         
        const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
        const b = a.slice(4,9);
        console.log("b = " + b);

        const c = a.slice(4);
        console.log("c = " + c);

        const d = a.slice(4, -5);
        console.log("d = " + d);

 */

      /*
        - splice(시작위치, 삭제할개수, 추가할데이터들...)
            ==> 배열의 '시작위치'부터 '삭제할개수'만큼의 데이터를 삭제하고
                삭제한 자리에 '추가할데이터들'을 추가한다.
            ==> '삭제할 개수가 0이면 하나도 삭제되지 않는다.'
        */

      /*         
        const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
        console.log("변경전 : " + a);
        
        a.splice(5, 3, "가", "나");
        console.log("변경후 : " + a);     //1,2,3,4,5,가,나,9,10,11,12,13,14,15
        
        a.splice(8, 0, "a", "b", "c");    //1,2,3,4,5,가,나,9,a,b,c,10,11,12,13,14,15
        console.log("변경후 : " + a);

 */
      /*
        - sort()
            ==> 배열의 요소값들을 '오름차순'으로 정렬하여 재배치한다.
            ==> 배열의 요소값들을 '문자열'로 변환하여 정렬한다.
        
        - sort(정렬함수)
            ==> '정렬함수'를 이용하여 정렬 방식을 결정한다.
            ==> '정렬함수'는 파라미터 변수가 2개로 구성되어 있고 배열의 인접해 있는 데이터 2개를 가져와 비교하는 
                역할을 수행한다.
            ==> '정렬함수'의 반환값이 '양수'이면 인접한 2개의 데이터의 순서가 바뀌고,
                '음수'를 반환하면 순서가 변하지 않는다.(같을 때는 0을 반환한다.)
            
        정렬함수 형식)
            function 정렬함수명(변수1, 변수2){
                //오름차순 예
                if(변수1 < 변수2){
                    return -1;
                }else{
                    return 1;
                }
            }
        */

      /* 
        const a = [90, 70, 95, 100, 75, 80];
        console.log("정렬전 : " + a);

        a.sort();
        console.log("정렬후 : " + a);

        //정렬함수 정의
        function comp(x, y){
            if(x < y){
                return -1;
            }else{
                return 1;
            }
        }

        a.sort( comp );
        console.log("정렬 후 : " + a);

         
        a.sort( function (x, y){
            if(x > y){
                return -1;
            }else{
                return 1;
            }
        });
         


        
        a.sort( (x, y) => {
            if(x > y){
                return -1;
            }else{
                return 1;
            }
        });
        

        console.log("-- 정렬 후 : " + a );


 */

      //------------------------------------------------

      /*
        - forEach(callback)
            ==> 배열 요소 개수만큼 차례로 callback함수를 호출하여 처리한다.
            형식) forEach ( function(요소값, index, this값) {처리할 내용들;} )
        */

      /*         
        const arr =[ 'a', 'b', 'c' ];

        arr.forEach( (value, index, myArr) => {
            console.log(`value = ${value}, index = ${index}, myArr = ${myArr}`);
        });

        console.log("------------------------");

        arr.forEach( (value) => {
            console.log(value);
        } );
 */

      /*
        - find(callback)
            ==> 배열 요소 개수만큼 차례로 callback함수를 호출하고, 이 callback함수의 반환값이 true인 첫번째 요소를
                반환한다.
            ==> 반환값이 true인 데이터가 하나도 없으면 undefined를 반환한다.
            형식) find( function(요소값, index, this값){
                return 조건식;
            })
        
        - findIndex(callback), findLastIndex(callback)
            ==> 배열의 요소값을 하나씩 이용하여 callback함수를 호출하고
                이 callback함수의 반환값이 true인 첫번째 요소의 index값을 반환한다.
            ==> 반환값이 true인 데이터가 하나도 없으면 -1을 반환한다.
            ==> findIndex()는 앞에서 뒤쪽 방향으로 검색하고, findLastIndex()는 뒤에서
                앞쪽 방향으로 검색한다.

        */
      /* 
      let arr = [10, 20, 30, 40, 50];
      console.log(arr.find((value) => value > 25));

      console.log(arr.findIndex((value) => value > 25));

      console.log(arr.findLastIndex((value) => value > 25));
     */

      /*
        -map(callback)
            ==> 배열의 요소값을 하나씩 이용하여 callback함수를 호출하고
                이 callback함수의 반환값들로 구성된 새로운 배열을 반환한다.
                (원본 배열 불변)
            형식)
                map( function(요소값, index, this값){
                    return 반환값;
                });
    */

      /* 
      const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      //const doublceArr = arr.map((num) => num *2);
      const doubleArr = arr.map((num) => {
        return num * 2;
      });

      console.log("arr", arr);
      console.log("doubleArr", doubleArr);
 */
      /*
        - filter(callback)
            ==> 배열 요소값을 하나씩 이용하여 callback함수를 호출하고 이 callback함수의 반환값이
                true인 요소들로 구성된 새로운 배열을 반환한다.
                (원본 배열 불변)
            형식)
                filter(function(요소값, index, this값){
                    return 조건식;
                });
        */
      /* 
        const arr = [1,2,3,4,5,6,7,8,9];
        const evenArr = arr.filter ( num => num % 2 ==0);

        console.log("arr", arr);
        console.log("evenArr", evenArr);

 */
      /*
            - some(callback)
                => 배열 요소값을 하나씩 이용하여 callback함수를 호출하고 이 callback함수의
                    반환값이 단 한번이라도 참(true)인 경우에는 true를 반환하고,
                    모두 거짓(false)이면 false를 반환한다.
                형식)
                    some(function(요소값, index, this값){
                        return 조건식;
                    });


            - every(callback)
                => 배열 요소값을 하나씩 이용하여 callback함수를 호출하고 이 callback함수의
                    반환값이 모두 참(true)이면 true를 반환하고 단 한번이라도 거짓(false)이면
                    false를 반환한다.
                형식)

        */

      /*  
      const arr = [10, 20, 30, 40, 50];
      console.log (arr.some(num => num > 45)); //true
      console.log (arr.some(num => num > 50)); //false

      console.log( arr.every( num => num > 5)); // true
      console.log( arr.every( num => num > 45)); // false
    */
      /*
            - reduce(callback, 이전초기값)
                => 배열 요소값을 하나씩 이용하여 callback함수를 호출하고
                    이 callback함수의 반환값을 다음 순회시 callback함수의 첫번쨰 인수로
                    전달하면서 callback함수를 호출하여 하나의 결과값을 만들어 반환한다.
                    '이전초기값'이 있으면 이 값이, 없으면 배열의 첫번째 요소가 callback함수의
                    '초기값'에 저장되어 실행된다.
                    (원본 배열 불변)
                형식)
                    reduce( function(초기값 또는 콜백함수의 이전 반환값, 요소값, index, this값){
                        return 반환값;
                    }, 이전초기값 );
        */

      /*  
      const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
      const sum = arr.reduce((acc, num) => acc + num, 0);

      console.log("sum = " + sum);

      const sum2 = arr.reduce((acc, num) => acc + num);
      console.log("sum2 = " + sum2);
        */

      //다음과 같은 장바구니 정보가 있다.
      const cartItems = [
        { id: 1, name: "노트북", price: 1500000, inStock: true },
        { id: 2, name: "마우스", price: 50000, inStock: false },
        { id: 3, name: "키보드", price: 100000, inStock: true },
        { id: 4, name: "모니터", price: 300000, inStock: true },
        { id: 5, name: "TV", price: 1200000, inStock: false },
        { id: 6, name: "냉장고", price: 2500000, inStock: true },
        { id: 7, name: "세탁기", price: 800000, inStock: true },
      ];

      /* 
      문제) 장바구니에 담긴 상품 목록 중 품절되지 않은 상품만 골라 10% 할인된 가격을
           적용한 새 배열을 생성하시오.
           (새 배열에 저장될 item의 구성요소 : id, name, price, discountPrice)
           힌트) filter()메서드와, map()메서드를 이용한다.
     */
    </script>
  </head>
  <body></body>
</html>
